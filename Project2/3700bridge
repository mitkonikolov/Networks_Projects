#!/usr/bin/python -u    
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import time
import json
import random


class Bridge(object):
    id = -1
    LAN = None
    sockets = []
    # the current root
    root_id = -1
    cost = 0
    # file number of the port associated with the root
    root_port = -1 # the port to use to get to root
    # send messages through this object
    message = None
    # unique LANs we are connected to and ports through which we connect to them
    uniqueLANs = {}
    # file numbers for the active ports
    routing_table = {}
    # a dictionary of ports; each port maps to a list of (BPDU, time) tuple
    port_history = {}
    enabled_ports = []
    # has the tree been found to fail
    failed_tree = False
    # neighbor maps to (port, the last time they broadcasted)
    neighbor_time = {}
    # currently disabled port -> [(message, time) ...]
    send_buffer = {}
    time_tree_failed = ""

    def __init__(self, id, LAN):
        self.id = id
        self.LAN = LAN
        self.root_id = id
        print("Bridge "+ str(self.id) +" starting up")
        open("ports.txt", "w+").close()

    def pad(self, name):
        '''Pads the name with null bytes at the end
        
        :param name: the LAN name that needs to be padded
        :return: the padded name
        '''
        result = "\0" + name
        while len(result) < 108:
            result += "\0"
        return result.encode()

    def connect_to_sockets(self):
        ''' Connects to all the sockets in self.LAN 
        
        :return: None
        '''
        for x in range(len(self.LAN)):
            s = My_Socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(self.pad(self.LAN[x]))
            self.sockets.append(s)
            # all sockets are enabled initially
            self.enabled_ports.append(s)
            self.port_history[s] = []
        self.message = Message(self.sockets)

    def start(self):
        ''' Starts the bridge and calls all helper methods to perform 
        different aspects of its functionality.
        
        :return: None
        '''

        # first broadcast
        self.broadcast_bpdu()
        # the time of the most recent broadcast
        last_mess_time = time.time() * 100

        while True:
            self.recover()
            self.check_for_failures()

            curr_time = time.time() * 100
            # the maximum slack time after which the bridge needs to broadcast
            diff = 0.5 - ((curr_time - last_mess_time)/100)

            # if it has been 490ms since last broadcast, broadcast again
            if (curr_time-last_mess_time) > 49:
                diff = 0.5
                last_mess_time = time.time() * 100
                self.broadcast_bpdu()

            # Calls select with all the sockets; change the timeout value (1)
            ready, ignore1, ignore2 = select.select(self.sockets, [], [],
                                                    diff - abs(diff/4))
            # Reads from each fo the ready sockets
            for socket in ready:
                data = socket.recv(1500)
                # keep a log of the incoming packets
                # f = open("out.txt", "a")
                # f.write(data)
                # f.write("\n")
                # f.close()
                if self.message.is_BPDU(data):
                    self.process_bpdu(socket, data)
                else:
                    # ports that I need to listen to
                    if socket in self.enabled_ports:
                        self.pack_send(socket, data)


    def process_bpdu(self, socket, data):
        '''Process the BPDU message given in data and update root if necessary.
        
        :param socket: the My_Socket where the @param data arrived 
        :param data: the BPDU message to be processed
        
        :return: None 
        '''
        # there have been no BPDUs on this socket/port
        if socket not in self.port_history or self.port_history[socket] is None:
            self.port_history[socket] = []
        time_now = time.time() * 100
        tup1 = (data, time_now)
        # store the time when the BPDU arrived and map it to the socket
        self.port_history[socket].append(tup1)

        peer_name = socket.getpeername()
        file_no = socket.fileno()
        # currently do not have a designated port for the LAN
        if peer_name not in self.uniqueLANs:
            self.uniqueLANs[peer_name] = file_no
            print("Designated port: {}/{}".format(self.id, file_no))
            print(
                "The designated port connects to the LAN {}".format(peer_name))
        if self.is_from_me(data):
            if peer_name in self.uniqueLANs and file_no !=  self.uniqueLANs[
                peer_name]:
                if socket in self.enabled_ports:
                    self.enabled_ports.remove(socket)
                print("Disabled port: {}/{}\n".format(self.id, file_no))
                print("The disabled port connects to {}\n".format(peer_name))
        else:
            self.update_root(socket, data)
        self.update_enabled_ports()


    def update_root(self, socket, data):
        ''' Checks whether the given BPDU message would cause a change in the
        root and if so, it updates the root.
        
        :param socket:  the My_Socket where the @param data arrived 
        :param data: the BPDU message to be processed
        
        :return: None
        '''
        try:
            foreignBPDU = json.loads(data)

            neighbor = foreignBPDU['source']
            self.neighbor_time[neighbor] = (socket, time.time() * 100)
            if int(str(foreignBPDU['message']['root']), 16) < \
                    int(str(self.root_id), 16) or \
                    (int(str(foreignBPDU['message']['root']), 16) ==
                         int(str(self.root_id), 16) and
                             int(str(foreignBPDU['message']['cost']), 16) <
                             (int(str(self.cost), 16) - 1)):
                self.root_id = foreignBPDU['message']['root']
                self.cost = foreignBPDU['message']['cost'] + 1
                self.root_port = socket.fileno()
                if socket not in self.enabled_ports:
                    self.enabled_ports.append(socket)
                self.broadcast_bpdu()
                print("New root: {}/{}".format(self.id,
                                               self.root_id))
                print("Root port: {}/{}".format(self.id,
                                                self.root_port))
                self.update_enabled_ports()
                # new root -> flush the routing table
                self.routing_table = {}
        except Exception as e:
            print(e)


    def pack_send(self, socket, data):
        ''' Process the given data message, pack all destination ports into 
        one variable, send the message and store data into a buffer.
        
        :param socket: the My_Socket where the @param data arrived  
        :param data: the data message that needs to be processed
        
        :return: None
        '''
        # keep a log of the received messages
        # rec_mess = open("received_mess.txt", "a")
        # rec_mess.write(
        #     "Bridge id {}, root is {}\n".format(self.id, self.root_id))
        # rec_mess.close()
        # extract source and put in forwarding table
        data_dict = json.loads(data)
        source = data_dict['source']
        tuple1 = (socket, time.time() * 100)
        self.routing_table[source] = tuple1
        self.update_routing_table()
        # extract destination and check whether we have it
        destination = data_dict['dest']
        dest_ports = []
        if destination in self.routing_table:
            # only send if the two hosts are on different ports
            if self.routing_table[destination][0] != socket and \
                            self.routing_table[destination][
                                0] in self.enabled_ports:
                dest_ports.append(self.routing_table[destination][0])
        else:
            for x in self.enabled_ports:
                if x != socket:
                    dest_ports.append(x)
        self.message.send(data, dest_ports)
        self.store_into_buffer(socket, data, dest_ports)


    def store_into_buffer(self, socket, data, dest_ports):
        ''' Stores the given data into self.send_buffer mapping it to the given
         socket.
        
        :param socket: the My_Socket where the @param data arrived  
        :param data: the message to be buffered 
        :param dest_ports: the ports to which the message is going to be sent
        
        :return: None
        '''
        # store the places there the packets could be going
        for x in self.sockets:
            # this port is not a destination and not in
            if x not in dest_ports and (x.getpeername() in self.uniqueLANs
                and x.fileno() == self.uniqueLANs[x.getpeername()]) and x != \
                    socket:
                if not self.designated_bridge_is_there(x):
                    # I have not heard from the designated recently so buffer
                    # the data
                    if x not in self.send_buffer:
                        self.send_buffer[x] = []
                    self.send_buffer[x].append(
                        (data, time.time() * 100, socket))
                    break
        self.update_send_buffer()


    def recover(self):
        ''' Recover information that could have been lost by sending the data
        that was buffered.
        
        :return: None
        '''
        # the tree has failed and it has been at least 500ms
        if self.failed_tree and (time.time() * 100 -
                                     self.time_tree_failed) > 50:
            for entry in self.send_buffer:
                if entry not in self.send_buffer:
                    continue
                for message in self.send_buffer[entry]:
                    data = message[0]
                    socket = message[1]
                    self.failed_tree = False
                    data_dict = json.loads(data)
                    # extract destination and check whether we have it
                    destination = data_dict['dest']
                    dest_ports = []
                    for host in self.routing_table:
                        if destination in self.routing_table:
                            # only send if the two hosts are on different ports
                            if self.routing_table[destination][0] != socket and\
                                            self.routing_table[destination][0] \
                                            in self.enabled_ports:
                                dest_ports.append(
                                    self.routing_table[destination][0])
                        else:
                            for x in self.enabled_ports:
                                if x != socket:
                                    dest_ports.append(x)
                    self.message.send(data, dest_ports)
                    self.send_buffer = {}


    def update_send_buffer(self):
        '''Update self.send_buffer by removing all messages older than
        750 ms.
        
        :return: None
        '''
        new_buffer = {}
        for port in self.send_buffer:
            for message in self.send_buffer[port]:
                # the bridge for this port might have failed and this might
                # have not been discovered yet; the message is preserved.
                if time.time()*100 - message[1] < 75:
                    if port not in new_buffer:
                        new_buffer[port] = []
                    new_buffer[port].append(message)
        self.send_buffer = new_buffer


    def designated_bridge_is_there(self, port):
        ''' Returns True if in the last 100ms on the given port, there has been
        a message from a bridge that is more fit than self to pass the message
        to the root.
    
        If there has not been a message from another bridge, then False is
        returned indicating that the data should be buffered for now.
        
        :param port: the port that needs to be checked for the presence of a
        better fitting bridge 
         
        :return: boolean indicating whether there has been a message on the 
        given port in the last 100ms
        '''
        if port in self.port_history:
            bpdus = self.port_history[port]
            for message in bpdus:
                # this bridge is more fit than me and has sent a BPDU in the
                # last 100ms
                if (time.time()*100 - message[1]) < 10 and \
                        self.is_better_than_me(message[0]):
                    return True
        return False


    def is_better_than_me(self, bpdu):
        ''' Returns True if the given bpdu was from a bridge that would be
        designated on the port over self.
        
        :return: boolean indicating if the bridge from the given bpdu would be
                 a designated bridge over self
        '''
        json_obj = json.loads(bpdu)
        if json_obj['message']['cost'] == self.cost and \
                        int(json_obj['source'], 16) < int(str(self.id), 16) and \
                        int(str(json_obj['message']['root']), 16) == \
                        int(str(self.root_id), 16):
            return True
        if json_obj['message']['cost'] < self.cost and \
                        int(str(json_obj['message']['root']), 16) == \
                        int(str(self.root_id), 16):
            return True
        return False


    def broadcast_bpdu(self):
        ''' Broadcasts bpdu message to all ports.
        
        :return: None
        '''
        self.message.send_message(self.id, "FFFF", "bpdu", {"root": \
                                                            self.root_id,
                                                            "cost":self.cost})


    def check_for_failures(self):
        ''' Checks whether there has been a bpdu from all neighboring bridges
        in the last 750 ms. If a neighbor has not sent a bpdu in the time
        period, then it sets self.failed_tree to True and record the time of
        the failure in self.time_tree_failed.
        
        :return: None
        '''
        new_neighbors = {}
        for neighbor in self.neighbor_time:
            if (time.time()*100) - self.neighbor_time[neighbor][1] >= 75:
                self.time_tree_failed = time.time()*100
                self.failed_tree = True
                self.root_id = self.id
                self.cost = 0
                self.root_port = -1
                print("Root port: {}/{}".format(self.id, self.root_port))
                self.enabled_ports = []
                for s in self.sockets:
                    self.enabled_ports.append(s)
                self.routing_table = {}
                self.port_history = {}
                self.uniqueLANs = {}
            else:
                new_neighbors[neighbor] = self.neighbor_time[neighbor]
        if len(new_neighbors)!=len(self.neighbor_time):
            self.neighbor_time = new_neighbors


    def update_routing_table(self):
        ''' Update the routing table by dropping all entries older than 5s.
        
        :return: None
        '''
        new_table = {}
        for host in self.routing_table:
            port_time = self.routing_table[host]
            if (time.time()*100) - port_time[1] < 500:
                new_table[host] = (port_time[0], port_time[1])
        self.routing_table = new_table


    def update_port_history(self):
        '''Update the port history by removing BPDUs older than 750ms.
        
        :return: None
        '''
        new_port_history = {}
        for port in self.port_history:
            new_port_history[port] = []
            messages = self.port_history[port]
            for message in messages:
                if time.time()*100 - message[1] < 75:
                    new_port_history[port].append(message)
        self.port_history = new_port_history


    def update_enabled_ports(self):
        '''Updates the list of enabled ports.
        
        :return: None
        '''
        # This is the root => all ports are enabled
        if self.root_id == self.id:
            for s in self.sockets:
                # this port is not enabled and we are not already connected to
                # this LAN
                if s not in self.enabled_ports and  s.getpeername() not in \
                        self.uniqueLANs:
                    self.enabled_ports.append(s)
            return
        self.update_port_history()
        # the tree has failed and needs to be reconstructed
        for port in self.port_history:
            # Reason B: this is the root port
            if port.fileno() == self.root_port:
                # it has already been added so no routing table updates
                continue
            bpdus = self.port_history[port]
            designated_bridge = True
            if len(bpdus) == 0:
                continue
            for message in bpdus:
                # some other bridge is designated for this LAN
                if self.is_better_than_me(message[0]):
                    designated_bridge = False
                    break
            # Reason C: this is the designated bridge or
            # no BPDUs younger than 750ms
            if designated_bridge or len(self.port_history[port])==0:
                # change state so flush routing table
                if port not in self.enabled_ports:
                    self.enabled_ports.append(port)
                    self.routing_table = {}
                continue
            if port in self.enabled_ports:
                # flush routing_table because of change of state
                self.routing_table = {}
                self.enabled_ports.remove(port)
                print("Disabled port: {}/{}".format(self.id, port.fileno()))
                print("The disabled port connects to {}".format(port.getpeername()))


    def is_from_me(self, bpdu):
        '''Check if the given BPDU was sent by self.
        
        :param bpdu: a message to check 
        :return: boolean indicating whether the bpdu is from self
        '''
        bpdu_dict = json.loads(bpdu)
        return bpdu_dict['source'] == self.id


    def __eq__(self, other):
        """Overrides the default implementation of __eq__.
        
        :param other: another bridge
        :return: boolean indicating whether this bridge is the same as other
        """
        if isinstance(self, other.__class__):
            #return self.fileno() == other.fileno()
            return self.id  == other.id
        return False


    def __ne__(self, other):
        """Overrides the default implementation of __ne__.
        
        :param other: another bridge
        :return: boolean indicating whether this bridge is different from other
        """
        return not self.__eq__(other)



class My_Socket(socket.socket):

    def __init__(self, val1, val2):
        super(My_Socket, self).__init__(val1,val2)
        #self.queue = queue.Queue

    def __eq__(self, other):
        '''Overrides the default implementation of __eq__ for socket.
        
        :param other: the other object that needs to be compared to self
        :return: True if the self and other are equivalent
        '''
        if isinstance(self, other.__class__):
            return self.fileno() == other.fileno()
        return False

    def getpeername(self):
        '''Returns the peername of the network to which this socket is
        connected.
        
        :return: the peername of the network to which this socket is connected 
        '''
        return super(My_Socket, self).getpeername()


    def fileno(self):
        '''Returns the file number for this socket.
        
        :return: the file number for this socket
        '''
        return super(My_Socket, self).fileno()



class Message(object):
    # all the sockets to which this message could be sent
    sockets = {}

    def __init__(self, sockets):
        self.sockets = sockets


    def send_message(self, source, dest, type, message):
        ''' Packs and sends the message based on the given data
        
        :param source: the source for the message
        :param dest: the destination for the message
        :param type: the type of the message
        :param message: the message itself
        :return: None
        '''
        if type == "bpdu": # broadcast
            m = {}
            m['source'] = source
            m['dest'] = dest
            m['type'] = type
            m['message'] = message
            m['message']['id'] = self.gen_RN()
            m = json.dumps(m).encode('utf-8')
            for s in self.sockets:
                s.send(m)


    def is_BPDU(self, json_str):
        '''Checks whether the given string is a BPDU message.
        
        :param json_str: a string which is the message that arrived
        :return: True if the message is a BPDU, False otherwise
        '''
        dict_message = json.loads(json_str)
        val = dict_message['type']
        return val == "bpdu"


    def gen_RN(self):
        '''Generates and returns a random number.
        
        :return: a random number
        '''
        return random.choice('0123456789abcdef') + random.choice(
            '0123456789abcdef') + random.choice('0123456789abcdef') + \
               random.choice('0123456789abcdef')


    def set_ports(self, ports):
        '''Sets self.sockets to the given ports.
        
        :param ports: all the ports that this Message might send to
        :return: None
        '''
        self.sockets = ports


    def send(self, message, ports):
        '''Sends the message on the given ports.
        
        :param message: the message that needs to be sent
        :param ports: the ports to which the message needs to be sent
        :return: None
        '''
        for s in ports:
            s.send(message)



if __name__ == "__main__":
    # bridge ID
    id_main = sys.argv[1]
    # LANs the bridge is connecting to
    LAN_main = sys.argv[2:]

    # create the bridge
    bridge_main = Bridge(id_main, LAN_main)
    # connect to sockets
    bridge_main.connect_to_sockets()
    # start the bridge
    bridge_main.start()