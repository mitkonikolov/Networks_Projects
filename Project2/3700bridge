#!/usr/bin/python -u    
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import threading
import time
import json
import random
import string




class Bridge(object):
    id = -1
    LAN = None
    sockets = []
    root_id = -1 # the current root
    cost = 0
    # file number of the port associated with the root
    root_port = -1 # the port to use to get to root
    message = None
    # unique LANs we are connected to and ports through which we connect to them
    uniqueLANs = {}
    # file numbers for the active ports
    activePorts = []
    inactivePorts = []
    routing_table = {}
    # a dictionary of ports; each port maps to a list of (BPDU, time) tuple
    port_history = {}
    enabled_ports = []
    # has the tree been found to fail
    failed_tree = False
    neighbor_time = {}

    def __init__(self, id, LAN):
        self.id = id
        self.LAN = LAN
	self.root_id = id
        print("Bridge "+ str(self.id) +" starting up")
	open("ports.txt", "w+").close()

    # pads the name with null bytes at the end
    def pad(self, name):
        result = '\0' + name
        while len(result) < 108:
            result += '\0'
        return result

    def connect_to_sockets(self):
        for x in range(len(self.LAN)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
	    #name = self.pad(self.LAN[x])
	    #f = open("ports.txt", "a") 
	    #f.write("{}\n".format(name))           
	    s.connect(self.pad(self.LAN[x]))
	    #f.write("{}\n\n".format(s.fileno()))
            self.sockets.append(s)
	    self.activePorts.append(s)
	    self.enabled_ports.append(s)
	    self.port_history[s] = []
	    #f.close()
        self.message = Message(self.sockets)

    def start(self):
        # TODO print out the messages that the assignment requires
        # broadcast first message to start the process of building a spanning
        #  tree
	
        self.broadcast_bpdu()
	last_mess_time = time.time() * 100

        while True:
	    self.check_for_failures()

	    curr_time = time.time() * 100
	    diff = 0.5 - ((curr_time - last_mess_time)/100)

	    if (curr_time-last_mess_time) > 50:
		diff = 0.5
	   	last_mess_time = time.time() * 100
		self.broadcast_bpdu()

	    while ((time.time()*100) - curr_time) < abs(diff/4):
		self.check_for_failures()

	     
            # Calls select with all the sockets; change the timeout value (1)
            ready, ignore1, ignore2 = select.select(self.sockets, [], [], diff - abs(diff/4))
	    if len(ready)==0:
		self.check_for_failures()
            # Reads from each fo the ready sockets
            for socket in ready:
                data = socket.recv(1500)
	        f = open("out.txt", "a")
		f.write(data)
		f.write("\n")
		f.close()
                if self.message.is_BPDU(data):
		    # there have been no BPDUs on this socket/port
		    if socket not in self.port_history or self.port_history[socket] is None:
			self.port_history[socket] = []
		    time_now = time.time() * 100
		    tup1 = (data, time_now)
		    self.port_history[socket].append(tup1)
		    if self.is_from_me(data):
			peer_name = socket.getpeername()
			file_no = socket.fileno()
			if socket not in self.inactivePorts and peer_name in self.uniqueLANs and file_no != self.uniqueLANs[peer_name]:
			    self.activePorts.remove(socket)
			    if socket in self.enabled_ports:
				self.enabled_ports.remove(socket)
			    self.inactivePorts.append(socket)
			    f = open("ports.txt", "a")
			    f.write("inactive: {}\n".format(socket.fileno()))
			    f.close()
			elif peer_name not in self.uniqueLANs:
			    self.uniqueLANs[peer_name] = file_no
                    else:
			
                        try:
                            foreignBPDU = json.loads(data)
			    
			    neighbor = foreignBPDU['source']
			    self.neighbor_time[neighbor] = time.time()*100
			    if self.failed_tree:
				self.root_id = self.id # the current root
    				self.cost = 0
    				# file number of the port associated with the root
    				self.root_port = -1 # the port to use to get to root
    				# unique LANs we are connected to and ports through which we connect to them
    				self.uniqueLANs = {}
    				# file numbers for the active ports
    				self.activePorts = self.sockets
    				self.inactivePorts = []
				self.enabled_ports = self.sockets
				self.port_history = {}
				self.routing_table = {}
				last_mess_time = 0
				self.failed_tree = False
				self.neighbors_time = {}
				break
				




			    if int(str(foreignBPDU['message']['root']), 16) < \
                                    int(str(self.root_id), 16) or \
			       (int(str(foreignBPDU['message']['root']), 16) ==
                                     int(str(self.root_id), 16) and
                                             int(str(foreignBPDU['message']['cost']), 16) <
                                             (int(str(self.cost), 16) - 1)): 
				self.root_id = foreignBPDU['message']['root']
                                self.cost = foreignBPDU['message']['cost'] + 1
                                self.root_port = socket.fileno()
				if socket not in self.enabled_ports:
				    self.enabled_ports.append(socket)
                                self.broadcast_bpdu()
				f = open("out.txt", "a")
                                f.write("New root: {}/{}".format( self.id,
                                                                self.root_id))
				f.write("\n")
				f.close()
				self.update_enabled_ports(True)

				# new root -> flush the routing table
				self.routing_table = {}
                        except Exception as e:
                            print(e)
                            print("BPDU was malformed and is " + data)
		    self.update_enabled_ports(True)
		    f  = open("out.txt", "a")
		    f.write("Enabled ports for {}:\n".format(self.id))
		    for s in self.enabled_ports:
			f.write("{}\n".format(s.getpeername()))
		    f.close()
		else:
		    		    #f = open("out.txt", "a")
		    #f.write("\nActive Ports\n")
		    #f.write(str(type(socket)))
		    #for port in self.activePorts:
		#	f.write("{}\n".format(port.fileno()))
		 #   f.write(str(socket.fileno()))
		  #  f.write(data)
		    #f.close()
		    
		    # prevent reading from multiple ports
		    #if socket not in self.inactivePorts:
		    if socket in self.enabled_ports:
			rec_mess = open("received_mess.txt", "a")
		    	rec_mess.write("Bridge id {}, root is {}, time is {}: {}\n".format(self.id,self.root_id,time.time()*100,  data))
		    	rec_mess.close()

		    #if socket in self.activePorts:
		   # 	f.write("\n------END-------\n")
		#	f.close()
			# extract source and put in forwarding table
			data_dict = json.loads(data)
			source = data_dict['source']
			tuple1 = (socket, time.time()*100)
			self.routing_table[source] = tuple1
			self.update_routing_table()
			# extract destination and check whether we have it
			destination = data_dict['dest']
			dest_ports = []
			f = open("out.txt", "a")
			f.write("\nRouting table for {}:\n".format(self.id))
			for host in self.routing_table:
			    f.write("Host: {} - Network: {} at time {}\n\n".format(host, self.routing_table[host][0].getpeername(), self.routing_table[host][1]))
			#f.close()
			if destination in self.routing_table:
			    f.write("destination is in routing table\n")
			    # only send if the two hosts are on different ports
			    if self.routing_table[destination][0] != socket and self.routing_table[destination][0] in self.enabled_ports:
			        dest_ports.append(self.routing_table[destination][0])
			else:
			    f.write("destination is not in routing table\n")
			    for x in self.enabled_ports:
				if x != socket:
				    dest_ports.append(x)
			self.message.send(data, dest_ports)
			f.write("there are {} destination ports:\n".format(len(dest_ports)))
			for d in dest_ports:
			    f.write("{}\n".format(d.getpeername()))
			f.write("\n\n\n")
			#f.write("\ndestination is {}\n".format(dest_ports[0]))
			f.close()
				# if we have it, forward to active ports
				# if we don't, broadcast to all active ports but port_number
	    #if ((time.time() * 100) - last_mess_time) < 200: 
	#	self.broadcast_bpdu()

    def broadcast_bpdu(self):
	f = open("out.txt", "a")
	f.write("{}/{} broadcasting\n".format(self.id, self.root_id))
	f.close()
        self.message.send_message(self.id, "FFFF", "bpdu", {"root":
                                                                self.root_id, "cost":self.cost})



    def check_for_failures(self):
	new_neighbors = {}
	for neighbor in self.neighbor_time:
	    #print("{} has root {} and neighbor {}".format(self.id, self.root_id, neighbor))
	    if (time.time()*100) - self.neighbor_time[neighbor] >= 75:
		#self.failed_tree = True
		# the root is down
		if self.root_id == neighbor or True:
		    
	    	    '''print("MISSING NEIGHBOR {}".format(neighbor))
		    f = open("out.txt", "a")
		    f.write("\n --------Root {} is down----------\n All ports are:\n".format(self.root_id))'''
		    self.root_id = self.id
		    self.cost = 0
		    self.root_port = -1
		    self.enabled_ports = []
		    self.activePorts = []
		    for s in self.sockets:
			#f.write("{}\n".format(s))
			self.enabled_ports.append(s)
			self.activePorts.append(s)
		    self.routing_table = {}
		    self.inactivePorts = []
		    self.port_history = {}
		    self.uniqueLANs = {}
		    '''f.write("New root is {} and new enabled ports are:\n".format(self.root_id))
		    for s in self.enabled_ports:
			f.write("{}\n".format(s))
		    f.close()'''
		    #del neighbor_time[neighbor]
		    #break
	    else:
		new_neighbors[neighbor] = self.neighbor_time[neighbor]
	if len(new_neighbors)!=len(self.neighbor_time):
	    self.neighbor_time = new_neighbors

    def update_routing_table(self):
	new_table = {}
	for host in self.routing_table:
	    port_time = self.routing_table[host]
	    if (time.time()*100) - port_time[1] < 500:
		new_table[host] = (port_time[0], port_time[1])
	self.routing_table = new_table

    def update_port_history(self):
	new_port_history = {}
	for port in self.port_history:
	    new_port_history[port] = []
	    messages = self.port_history[port]
	    for message in messages:
		if time.time()*100 - message[1] < 75:
		    new_port_history[port].append(message)
	self.port_history = new_port_history

    def update_enabled_ports(self, mode):
	# This is the root => all ports are enabled
	if self.root_id == self.id:
	    for s in self.sockets:
		if s not in self.enabled_ports:
		    self.enabled_ports.append(s)
	    #self.enabled_ports = self.sockets
	    return

	self.update_port_history()
	# the tree has failed and needs to be reconstructed
	if self.failed_tree:
	    return

	for port in self.port_history:
	    f =""
	    if mode:
	        f = open("all_ports.txt", "a")
	        f.write("Bridge {}, root {}, port is {}, current time is {} and history is\n".format(self.id, self.root_id, port.getpeername(), time.time()*100))
	        if port in self.port_history:
		    for m in self.port_history[port]:
		        f.write("{} at time {}\n".format(m[0], m[1]))
	        else:
		    f.write("Port does not have a history\n")    
	    # Reason B: this is the root port
	    if port.fileno() == self.root_port:
		if mode:
		    f.write("\n---this is the root port---\n")
		# it has already been added so no updates on routing table are necessary
		continue
	    bpdus = self.port_history[port]
	    latest_to_drop = 0
	    designated_bridge = True
	    new_list = []
	    if len(bpdus) == 0:
		if mode:
		    f.write("\nno BPDUS\n")
		continue
	    for message in bpdus:
		json_obj = json.loads(message[0])
		# some other bridge is designated for this LAN
		if json_obj['message']['cost'] == self.cost and int(json_obj['source'], 16) < int(str(self.id), 16) and int(str(json_obj['message']['root']), 16) == int(str(self.root_id), 16):
		        designated_bridge = False
			break
		if json_obj['message']['cost'] < self.cost and int(str(json_obj['message']['root']), 16) == int(str(self.root_id), 16):
		        designated_bridge = False
			break		
	    # Reason C: this is the designated bridge
	    if designated_bridge:
		if mode:
		    f.write("\n----Designated bridge-----\n")
		# change state so flush routing table
		if port not in self.enabled_ports:
		    self.enabled_ports.append(port)
		    self.routing_table = {}
		continue
	    # Reason A: there are not BPDUs younger than 750ms on this port
	    if len(self.port_history[port]) == 0:
		if mode:
		    f.write("no young BPDUs")
		if port not in enabled_ports:
		    self.enabled_ports.append(port)
		    self.routing_table = {}
		continue
	    if port in self.enabled_ports:
	    	if mode:
		    f.write("\n--------closing the port at time{}---------\n".format(time.time()*100))
		# flush routing_table because of change of state
		self.routing_table = {}
		self.enabled_ports.remove(port)

        # TODO Consider how to identify if a bridge has stopped working and a
        # TODO socket thus becomes useless


    def is_from_me(self, bpdu):
        bpdu_dict = json.loads(bpdu)
        return bpdu_dict['source'] == self.id

    def __eq__(self, other):
        """Overrides the default implementation"""
        if isinstance(self, other.__class__):
            return self.fileno() == other.fileno()
    	return False

    def __ne__(self, other):
        """Overrides the default implementation (unnecessary in Python 3)"""
        return not self.__eq__(other)


class Message(object):
    sockets = {}
    id = 0

    def __init__(self, sockets):
        self.sockets = sockets

    def send_message(self, source, dest, type, message):
        '''Packs and sends the message that was passed'''
        if type == "bpdu": # broadcast
            m = {}
            m['source'] = source
            m['dest'] = dest
            m['type'] = type
            m['message'] = message
            m['message']['id'] = self.gen_RN()
            m = json.dumps(m).encode('utf-8')
            for s in self.sockets:
                s.send(m)

    def is_BPDU(self, json_str):
        dict_message = json.loads(json_str)
        val = dict_message['type']
        return val == "bpdu"

    def gen_RN(self):
        '''Returns a random number'''
        return random.choice('0123456789abcdef') + random.choice(
            '0123456789abcdef') + random.choice('0123456789abcdef') + \
               random.choice('0123456789abcdef')

    def set_ports(self, ports):
        self.sockets = ports

    def send(self, message, ports):
	for s in ports:
	    #m = json.dumps(message).encode('utf-8')
	    s.send(message)



if __name__ == "__main__":
    # bridge ID
    id_main = sys.argv[1]
    # LANs the bridge is connecting to
    LAN_main = sys.argv[2:]

    bridge_main = Bridge(id_main, LAN_main)
    bridge_main.connect_to_sockets()
    bridge_main.start()

