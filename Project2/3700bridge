#!/usr/bin/python -u    
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import threading
import time
import json
import random
import string




class Bridge(object):
    id = -1
    LAN = None
    sockets = []
    root_id = -1 # the current root
    cost = 0
    # file number of the port associated with the root
    root_port = -1 # the port to use to get to root
    message = None
    # unique LANs we are connected to
    uniqueLANs = set()
    # file numbers for the inactive ports
    inactivePorts = []

    def __init__(self, id, LAN):
        self.id = id
        self.LAN = LAN
	self.root_id = id
        print("Bridge "+ str(self.id) +" starting up")

    # pads the name with null bytes at the end
    def pad(self, name):
        result = '\0' + name
        while len(result) < 108:
            result += '\0'
        return result

    def connect_to_sockets(self):
        for x in range(len(self.LAN)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(self.pad(self.LAN[x]))
            self.sockets.append(s)
        self.message = Message(self.sockets)

    def start(self):
        # TODO print out the messages that the assignment requires
        # broadcast first message to start the process of building a spanning
        #  tree
	
	f = open("out.txt", "w+")
	f.close()

        self.broadcast_bpdu()
        while True:
	    time.sleep(0.5)
	    self.broadcast_bpdu()
	    
            # Calls select with all the sockets; change the timeout value (1)
            ready, write, ignore2 = select.select(self.sockets, self.sockets, [], 0.5)
            # Reads from each fo the ready sockets
            for socket in ready:
                data = socket.recv(1500)
	        f = open("out.txt", "a")
		f.write(data)
		f.write("\n")
		f.close()
                if self.message.is_BPDU(data):
                    if self.is_from_me(data):
                        if socket.getpeername() in self.uniqueLANs:
                            # mark port as inactive - don't listen/send data
                            self.inactivePorts.append(socket.fileno())
                        else:
                            self.uniqueLANs.add(socket.getpeername())
                    else:
                        try:
                            foreignBPDU = json.loads(data)
			    if int(str(foreignBPDU['message']['root']), 16) < \
                                    int(str(self.root_id), 16) or \
			       (int(str(foreignBPDU['message']['root']), 16) ==
                                     int(str(self.root_id), 16) and
                                             int(str(foreignBPDU['message']['cost']), 16) <
                                             int(str(self.cost), 16)):
				self.root_id = foreignBPDU['message']['root']
                                self.cost = foreignBPDU['message']['cost'] + 1
                                self.root_port = socket.fileno()
                                self.broadcast_bpdu()
				f = open("out.txt", "a")
                                f.write("New root: {}/{}".format( self.id,
                                                                self.root_id))
				f.write("\n")
				f.close()
			    else:
				 print("here")
                        except Exception as e:
                            print(e)
                            print("BPDU was malformed and is " + data)


    def broadcast_bpdu(self):
	f = open("out.txt", "a")
	f.write("{}/{} broadcasting\n".format(self.id, self.root_id))
	f.close()
        self.message.send_message(self.id, "FFFF", "bpdu", {"root":
                                                                self.root_id, "cost":self.cost})

        # TODO Consider how to identify if a bridge has stopped working and a
        # TODO socket thus becomes useless

        # TODO Make broadcasting periodical

    def is_from_me(self, bpdu):
        bpdu_dict = json.loads(bpdu)
        return bpdu_dict['source'] == self.id


class Message(object):
    sockets = {}
    id = 0

    def __init__(self, sockets):
        self.sockets = sockets

    def send_message(self, source, dest, type, message):
        '''Packs and sends the message that was passed'''
        if type == "bpdu": # broadcast
            m = {}
            m['source'] = source
            m['dest'] = dest
            m['type'] = type
            m['message'] = message
            m['message']['id'] = self.gen_RN()
            m = json.dumps(m).encode('utf-8')
            for s in self.sockets:
                s.send(m)

    def is_BPDU(self, json_str):
        dict_message = json.loads(json_str)
        val = dict_message['type']
        return val == "bpdu"

    def gen_RN(self):
        '''Returns a random number'''
        return random.choice('0123456789abcdef') + random.choice(
            '0123456789abcdef') + random.choice('0123456789abcdef') + \
               random.choice('0123456789abcdef')

    def set_ports(self, ports):
        self.sockets = ports



if __name__ == "__main__":
    # bridge ID
    id_main = sys.argv[1]
    # LANs the bridge is connecting to
    LAN_main = sys.argv[2:]

    bridge_main = Bridge(id_main, LAN_main)
    bridge_main.connect_to_sockets()
    bridge_main.start()

'''

    # creates sockets and connects to them
    for x in range(len(LAN)):
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.connect(pad(LAN[x]))
        sockets.append(s)

    #initialize root_id and path_cost
    root_id = id
    path_cost = 0
    # root_port is not necessary in the beginning
    root_port = -1

    send_message(str(root_id), path_cost, sockets)

    #Main loop
    while True:
        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(sockets, [], [], 1)

        # Reads from each fo the ready sockets
        for x in ready:
            data = x.recv(1500)
            if(BPDU.isBpdu(data)):
                bpdu = None
                try:
                    foreignBPDU = BPDU(data)
                except Exception:
                    continue
                if foreignBPDU.root_id < root_id:
                    root_id = foreignBPDU.root_id
                    path_cost = foreignBPDU.path_cost
                    root_port = x.gethostname()
                    send_message(root_id, path_cost,
                                 sockets)
                elif foreignBPDU.root_id == root_id:
                    if foreignBPDU.path_cost < path_cost:
                        root_port = x.gethostname()
                        path_cost = foreignBPDU.path_cost
                        send_message(root_id,
                                     path_cost,
                                     sockets)
'''
# TODO
# 1. Confirm that tree building algo works for two/three bridges - make the
# bridge meet all requirements to the best of our ability and run the test
# script
# 2. Decide which ports are active
# 3. Build a forwarding table
# 4. Forward packets



