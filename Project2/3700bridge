#!/usr/bin/python -u    
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json




class Bridge(object):
    id = -1
    LAN = None
    sockets = []
    root_id = -1 # the current root
    cost = -1
    root_port = -1 # the port to use to get to root
    message = Message()

    def __init__(self, id, LAN):
        self.id = id
        self.LAN = LAN

    # pads the name with null bytes at the end
    def pad(self, name):
        result = '\0' + name
        while len(result) < 108:
            result += '\0'
        return result

    def connect_to_sockets(self):
        for x in range(len(self.LAN)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(self.pad(self.LAN[x]))
            sockets.append(s)

    def start_bridge(self):
        # TODO print out the messages that the assignment requires
        # broadcast first message to start the process of building a spanning
        #  tree
        self.__broadcast_bpdu()

        while True:
            # Calls select with all the sockets; change the timeout value (1)
            ready, ignore, ignore2 = select.select(sockets, [], [], 1)

            # Reads from each fo the ready sockets
            for x in ready:
                data = x.recv(1500)
                if (Message.is_BPDU(data)):
                    bpdu = None
                    try:
                        foreignBPDU = BPDU(data)
                    except Exception:
                        continue
                    if foreignBPDU.root_id < root_id or \
                            (foreignBPDU.root_id == root_id and
                                     foreignBPDU.path_cost < self.cost):
                        self.root_id = foreignBPDU.root_id
                        self.cost = foreignBPDU.path_cost
                        self.root_port = x.gethostname()
                        self.__broadcast_bpdu()

    def __broadcast_bpdu(self):
        # TODO think about how to better design the message class so sockets do
        # TODO not need to passed
        self.message.send_message(self.id, "FFFF", "bpdu", {"id":"1", "root":
            self.id, "cost":self.cost}, self.sockets)


class Message(object):
    source = ""
    dest = ""
    type = ""
    message = {}

    #TODO implement a method that generates unique IDs for messages

    # def send_message(id, path, sockets):
    #     '''Sends the message that was passed'''
    #     bpdu = str(id) + ";" + str(path)
    #     for s in sockets:
    #         s.send(bpdu)
            
    def send_message(self, source, dest, type, message, sockets):
        '''Packs and sends the message that was passed'''
        if type == "bpdu": # broadcast
            m = {}
            m['source'] = source
            m['dest'] = dest
            m['type'] = type
            m['message'] = message
            for s in sockets:
                s.send(bpdu)

    def is_BPDU(self, json_message):
        return json_message['type'] == "bpdu"


class BPDU(object):
    root_id = -1
    path_cost = -1

    def __init__(self, data):
        try:
            d = data.split(';')
            self.root_id = d[0]
            self.path_cost = d[1]
        except Exception:
            raise Exception('Invalid BPDU')
    @staticmethod
    def isBpdu(data):
        return len(packet.split(";")) == 2

if __name__ == "__main__":
    # bridge ID
    id = sys.argv[1]
    # LANs the bridge is connecting to
    LAN = sys.argv[2:]
    sockets = []

    bridge = Bridge(id, LAN)
    bridge.connect_to_sockets()



    # creates sockets and connects to them
    for x in range(len(LAN)):
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.connect(pad(LAN[x]))
        sockets.append(s)

    #initialize root_id and path_cost
    root_id = id
    path_cost = 0
    # root_port is not necessary in the beginning
    root_port = -1

    send_message(str(root_id), path_cost, sockets)

    #Main loop
    while True:
        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(sockets, [], [], 1)

        # Reads from each fo the ready sockets
        for x in ready:
            data = x.recv(1500)
            if(BPDU.isBpdu(data)):
                bpdu = None
                try:
                    foreignBPDU = BPDU(data)
                except Exception:
                    continue
                if foreignBPDU.root_id < root_id:
                    root_id = foreignBPDU.root_id
                    path_cost = foreignBPDU.path_cost
                    root_port = x.gethostname()
                    send_message(root_id, path_cost,
                                 sockets)
                elif foreignBPDU.root_id == root_id:
                    if foreignBPDU.path_cost < path_cost:
                        root_port = x.gethostname()
                        path_cost = foreignBPDU.path_cost
                        send_message(root_id,
                                     path_cost,
                                     sockets)
# TODO
# 1. Confirm that tree building algo works for two/three bridges - make the
# bridge meet all requirements to the best of our ability and run the test
# script
# 2. Decide which ports are active
# 3. Build a forwarding table
# 4. Forward packets



