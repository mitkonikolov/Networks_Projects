#!/usr/bin/env python

import sys, socket, select, time, json, random
from state import State

class Server:

    def __init__(self):
        # Your ID number
        self.my_id = sys.argv[1]

        # The ID numbers of all the other replicas
        self.replica_ids = sys.argv[2:]

        # Connect to the network. All messages to/from other replicas and clients will
        # occur over this socket
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.sock.connect(self.my_id)

        self.leader = "0000"
        self.state = State(self)
        self.reset_timeout()
        self.reset_last()

    def get_timeout(self):
        return self.timeout

    def reset_timeout(self):
        self.timeout = int((random.random() * 150) + 150)

    def reset_last(self):
        self.last = time.time() * 1000

    def get_state(self):
        return self.state.state

    def create_rpc(self, dst, type):
        # Send a no-op message to a random peer every two seconds, just for fun
        # You definitely want to remove this from your implementation
        return {"src": self.my_id, "dst": dst, "leader": self.leader, "type": type}

    def listen(self):
        self.reset_last()
        while True:
            ready = select.select([self.sock], [], [], 0.1)[0]
            # check whether a heartbeat needs to be sent
            mess = self.state.check_heart()
            if mess is not None:
                self.send(mess)
            if self.sock in ready:
                msg_raw = self.sock.recv(32768)

                if len(msg_raw) == 0: continue

                self.process_mess(msg_raw)
                # msg = json.loads(msg_raw)
                #
                # # For now, ignore get() and put() from clients
                # if msg['type'] in ['get', 'put']:
                #     pass
                #
                # # Handle noop messages. This may be removed from your final implementation
                # elif msg['type'] == 'noop':
                #     print '%s received a NOOP from %s' % (
                #     msg['dst'], msg['src'])

            clock = time.time() * 1000.0
            if self.state.state != "leader" and clock - self.last > \
                    self.timeout:
                print("{} and timeout is  {}".format((clock - self.last),
                                                   self.timeout))
                print("timedout, became candidate  " + self.my_id)
                self.become_candidate()



            # clock = time.time()
            # if clock - last > 2:
            #     # Send a no-op message to a random peer every two seconds, just for fun
            #     # You definitely want to remove this from your implementation
            #     msg = {'src': self.my_id, 'dst': random.choice(
            #         self.replica_ids), 'leader': 'FFFF', 'type': 'noop'}
            #     self.sock.send(json.dumps(msg))
            #     print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
            #     last = clock


            # ready = select.select([self.sock], [], [], 0.1)[0]
            #
            # if self.sock in ready:
            #     msg_raw = self.sock.recv(32768)
            #     print("{} received a mess from {}".format(msg['dst'], msg['src']))
                #self.process_mess(msg_raw)
            # clock = time.time() *1000.0
            # if self.state.state == "follower" and clock - self.last > self.timeout:
            #     print("timedout, became candidate  " + self.my_id)
            #     self.become_candidate()

    def become_candidate(self):
        msg = self.state.prepare_for_application()
        self.send(msg)
        print(json.dumps(msg))
        # reset the timer
        self.reset_last()

    def send(self, msg):
        self.sock.send(json.dumps(msg))

    def process_mess(self, msg_raw):
        if len(msg_raw) == 0:
            return

        print(self.log("received mess {}".format(msg_raw)))
        msg = json.loads(msg_raw)
        msg_type = msg['type']
        # the message is from self, not for self, or from an old term
        if msg['src'] == self.my_id or \
                (msg['dst'] != self.my_id and msg['dst'] != 'FFFF') or \
                (self.my_type(msg_type) and msg['term'] < self.state.term):
            return

        # forward on to the leader
        # if msg['type'] in ['get', 'put']:
        #     mess = {"src": self.my_id, "dst": msg["src"], "leader": self.leader,
        #             "type": "fail", "MID": msg["MID"]}
        #     self.sock.send(json.dumps(mess))

        # the current term already has a candidate
        if msg_type == 'heart' and self.state.is_candidate():
            self.state.go_back_to_follower()
        # a message from the current leader was received
        if msg_type == 'heart' and msg['leader'] == self.leader:
            self.log("received beat from {}".format(self.leader))
            self.reset_last()
        # the election was won so self needs to update its leader
        elif msg_type == 'won':
            self.leader = msg['leader']
            self.log("election was won updating leader to {}"
                     .format(self.leader))
        elif msg_type == 'vote':
            # self is not a candidate and it has not voted
            if self.state.voted_for is None and self.state.is_follower():
                self.send(self.state.vote(msg))
                self.log("{} voted for {}".format(self.my_id, msg['leader']))
                # a message from a candidate was received
                self.reset_last()
            # self is a candidate and is getting a vote
            elif self.state.is_candidate() and msg['leader'] == self.my_id:
                self.state.add_vote()
                self.log("there are {} replicas".format(len(self.replica_ids)))
                if self.state.vote_count > (len(self.replica_ids)/2):
                    self.become_leader()
                    self.log("won election and became leader")
                # reset timer to wait enough for votes to be cast
                self.reset_last()


    def become_leader(self):
        """Set all values for leadership.
        :return: None
        """
        self.leader = self.my_id
        self.state.set_leader()
        self.send(self.state.gen_heartbeat(True))

    def log(self, mess, error=False):
        if error:
            print("[err] {}".format(mess))
        else:
            print("[mess] {} {}".format(self.my_id, mess))

    def my_type(self, msg_type):
        return msg_type == 'heart' or msg_type == 'won' or msg_type == \
               'vote' or msg_type == 'append'

if __name__ =="__main__":
    s = Server()
    s.listen()
