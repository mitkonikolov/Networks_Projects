#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#


import sys
import zlib
import socket
import time
import datetime
import select
import json
from Logger import Logger
from Packet import Packet
from PacketLog import PacketLog


class Sender(object):
    logger = Logger()
    packet = None
    packet_log = PacketLog()
    prev_packet = None
    base = -1

    time_last_sent = 0

    MSG_SIZE = 1500
    DATA_SIZE = 1000
    SEQUENCE = 0

    def __init__(self):
        # Bind to localhost and an ephemeral port
        self.IP_PORT = sys.argv[1]
        self.UDP_IP = self.IP_PORT[0:self.IP_PORT.find(":")]
        self.UDP_PORT = int(self.IP_PORT[self.IP_PORT.find(":")+1:])
        self.dest = (self.UDP_IP, self.UDP_PORT)

        # Set up the socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.update_timeout()

        # the seq# of the last sent packet
        self.last_sent = 0
        # the seq# of the last acknowledged
        # self.last_ack = 0

    def retransmit(self, packet, eof = False):
        """ Retransmits the packet.
        :param packet: the packet to be retransmitted
        :return: bool
        """
        self.logger.log("retransmitting: {}".format(packet.seq_num))
        packet_sent_time = packet.send_packet(self.sock, self.dest, eof)
        # once successfully sent, we add packet to log and saves its sent_time
        if packet_sent_time!= -1:
            self.packet_log.update_log_time(self.packet, packet_sent_time)
        else:
            self.logger.log("[error] packet retransmission time is negative")

    def send_next_packet(self, eof = False, data = None):

        self.logger.log("inside packet sender")

        while s.packet_log.get_sws() > 0:
            if data is None:
                data = sys.stdin.read(self.DATA_SIZE)

            if (len(data) > 0 or eof):

                self.logger.log("data is {}".format(data))

                # if we're sending the first packet
                if self.prev_packet is None:
                    self.packet = Packet(data, "data", "")
                    self.base = self.packet.get_base()
                else:
                    self.packet = Packet(data, "data", "", self.prev_packet.get_seq_num(), self.base)

                # returns the time sent of the packet if success, -1 otherwise
                packet_sent_time = self.packet.send_packet(self.sock, self.dest, eof)

                # if failed sending the packet
                if packet_sent_time == -1:
                    s.logger.log("failed sending a packet, resending...")
                    self.retransmit(self.packet)
                    #return
                else:
                    # once successfully sent, we add packet to log and saves its sent_time
                    self.packet_log.add_to_log(self.packet, packet_sent_time)
                    self.prev_packet = self.packet
                    self.packet_log.update_sws(-1)

                #set data to None so we can read new data
                data = None
            else:
                # there is no more data to be sent
                return False
        # sws is depleted
        return False

    def update_timeout(self):
        """Updates timeout to its most recent value as stored in the PacketLog.
        
        :return: None
        """
        self.sock.settimeout(self.packet_log.get_timeout())


if __name__ == "__main__":
    s = Sender()
    succ_sent_eof = False

    # Now read in data, send packets
    while True:
        s.logger.log("ABOUT TO SLEEP")

        s.send_next_packet()
        # check if all packets have been ACKed first
        s.logger.log("packet timer size: {}".format(len(s.packet_log.packets_timers)))
        if not s.packet_log.still_waiting_acks():
            if succ_sent_eof:
                break
            else:
                s.send_next_packet(True, "")
                succ_sent_eof = True

        try:
            result = s.sock.recvfrom(s.MSG_SIZE)

            if result:

                s.logger.log("received some data")

                (raw_data, addr) = result
                receival_time = time.time()

                ack = s.packet.check_ack(zlib.decompress(raw_data))

                if ack:
                    dropped_packet = s.packet_log.update_unacked_packets(ack,
                        receival_time, s.packet.get_base(),
                        json.loads(raw_data)['buffered'])
                    # a packet has been dropped
                    if dropped_packet is not None:
                        s.logger.log("one or more packets are not getting acked, retransmitting those packets...")
                        s.retransmit(dropped_packet)
                for packet in s.packet_log.retransmit_table():
                    s.retransmit(packet)
                s.update_timeout()
        except socket.timeout as e:
            # timeout has occurred => packets are retransmitted and
            # timeout is being updated
            for packet in s.packet_log.retransmit_table(True):
                s.retransmit(packet)
            s.update_timeout()

    s.send_next_packet(True, "")
    s.send_next_packet(True, "")
    s.send_next_packet(True, "")
    s.logger.log("[completed]")
    sys.exit(0)