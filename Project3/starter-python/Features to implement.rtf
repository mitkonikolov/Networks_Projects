{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww33400\viewh19500\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 \
\
Triggering transmission\
\strike \strikec0 	a. The receiver needs to identify the size of its window size in order to advertise it - generally this is defined by a buffer but in our case it might be based on bandwidth too - this needs further consideration\
	b. The sender needs to identify an SWS (send window size) based on the min of the bandwidth and the advertised window\
	c. The sender must know its effective window - can it send anything or is it waiting for ACKs\
	d. The sender needs to identify an MSS - maximum segment size\
	e. The sender needs to know when is the best time to send - Nagle\'92s Algorithm\
	f. The sender must maintain a current waiting time for each packet so that it knows when to timeout a specific packet\strike0\striked0 \
\
\
Retransmitting dropped packets\
	a. Use Fast Retransmission: duplicate ACKs - always ACK the last packet before which everything else was received so we can know to resubmit some packet X earlier - this would need to also cancel to reset the timer on this packet X\
	b. Adaptive retransmission - needed because RTT varies over time and routes - the sender needs to calculate its timeout using Karn/Partridge; this also includes exponential backoff when a timeout occurs\
		- in order to implement Karn/Partridge, the sender needs to time each and every packet\
\
\
Sliding Window\
	a. The sender needs to maintain \
		- SWS - sending window size - how many unACKed packets can be sent\
		- LAR - last ACK received\
		- LFS - last frame sent\
	b. The receiver needs to maintain\
		- RWS - receive window size - upper bound on the number of out-of-order frames that the receiver can buffer\
		- LFR - last frame received - everything before this frame has been received and ACKed. It is better to always ACK the last received frame so if an older ACK has been lost, we ACK many frames by asking the last received one.\
		- LAF - last acceptable frame - the sum of RWS and LFR - the biggest Seq# that can be received out-of-order given LFR and RWS. Any frame that is < LFR and > LAF would be automatically discarded.\
\
\
Packet structure\
	a. Seq#\
	b. Data\
	c. Flag - D - data,A - ACK,DA - Data & ACK\
	d. AdvWindow\
	e. ACK - Seq#\
	f. Error checking	\
\
\
Notes\
	a. Make the Seq# a 64 bit field. Make the AdvertisedWindow a 64 bit field too - this doesn\'92t mean that the AdvertisedWindow will always be big but that it could be big enough to take advantage of the modern high-bandwidth networks.\
\
\
Tasks\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
To make it work:\
	1. [Either] Update recv to use Packet and PacketLog\
		note: Just import and use the functions from the class\
	2. [Mitko] Debug ./run \'97size medium, see what\'92s going on there\
	3. [Pair]Add features to recv\
		a. Ack to \'93correct\'94 packet\
			Note: this will include the duplicate acks and only sending back the \'93last packet before which we have all other \'93\
		b. Order packets in recv\
			1. log packets in the correct order\
			2. store unlogged/out of order packets\
		c. Find out which packet needs to be ignored\
			note: if you receive a packet that you already have (using the \'93last packet before which we have all other\'94 to check or the out of order packet\'92s list), ignore\
	4. [Ivan] Make sure CRC works on both send and recv\
		a. Implement CRC checker in Packet class to confirm the packet is correct\
		b.  Make sure to call this ^ in recv side\
	5. [Ivan] Print the required log messages on both send and recv\
	6. [Mitko] Implement Adaptive retransmission (see above)\
	7.  [Ivan] Update Logger functionality\
		a. Print debug messages to STDERR\
		b. Print data messages to STDOUT\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
To make it faster:\
	1. Figure out the buffer size of the OS (on Gordon)\
		note: dynamically check it in the code\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
To have lower overhead:\
	1. Make sure we have good timeouts to prevent us from sending duplicate packets\
		note: by using the Karn\'92s algorithm\
\
\
\
\
\
\
\
\
\
}