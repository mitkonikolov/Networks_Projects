#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#


import sys
import socket
import time
import datetime
import select
import json
import zlib
from Logger import Logger
from Packet import Packet
from PacketLog import PacketLog


class Receiver(object):
    logger = Logger()
    packet = Packet("", "ack", -1, -1)
    packet_log = PacketLog()

    # Bind to localhost and an ephemeral port
    UDP_IP = "127.0.0.1"
    UDP_PORT = 0
    TIMEOUT = 0.1

    # Set up the socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((UDP_IP, UDP_PORT))
    sock.settimeout(TIMEOUT)

    # Get port we bound to
    UDP_PORT = sock.getsockname()[1]
    logger.log("[bound] " + str(UDP_PORT))
    address = ""
    base = -1


if __name__ == "__main__":
    r = Receiver()
    base_is_set = False

    # Now listen for packets
    while True:
        try:
            result = r.sock.recvfrom(r.packet.get_msg_size())

            # If nothing is ready, we hit the timeout
            if result:
                (data, addr) = result

                try:
                    decoded = json.loads(zlib.decompress(data))
                    r.address = addr

                    # corrupted files
                    if not r.packet.is_good_crc(decoded["crc32"], decoded["data"]):
                        r.logger.log("bad crc")
                        continue

                    # If the EOF flag is set, exit
                    if (decoded['eof']):
                        r.logger.log("[completed]")
                        sys.exit(0)

                    if not base_is_set:
                        r.base = int(decoded["base"])

                    # TODO: call handle_packets and send an ack for the returned result if it's not None
                    ack = r.packet_log.handle_packet(decoded)


                    # Send back an ack to the sender
                    if ack is not None:
                        r.packet = Packet("", "ack", ack[0], ack[0])
                        r.packet.set_buffered(ack[1])

                        r.logger.log("ABOUT TO SEND {}".format(r.packet.generateData()))

                        packet_sent_time = r.packet.send_packet(r.sock, addr)

                        # currently not doing anything to packet_sent_time
                        if packet_sent_time == -1:
                            # NOTE: this should never be hit, if it hits, we should consider having
                            #       a while loop that keeps trying to resend the ack packet
                            # r.packet.send_packet(r.sock, addr)
                            r.logger.log("failed sending ack")
                            continue
                        else:
                            r.logger.log("successfully sent an ack")

                    # If there is data, we accept it and print it out
                    # TODO: change this to make sure we're printing in order
                    # if (decoded['data']):
                        # If we receive data, we assume it's in-order
                        # You will need to do much more here
                        # r.logger.log("[recv data] " + str(decoded['sequence']) + " (" +
                        #              str(len(decoded['data'])) + ") ACCEPTED (in-order)")
                        # r.logger.log_data(decoded['data'])

                except (ValueError, KeyError, TypeError) as e:
                    r.logger.log("[recv corrupt packet]")
                    print(e)
                    raise e
        except socket.timeout as e:
            r.logger.log("[error] timeout")
            if r.packet_log.get_last_received() == -1:
                prev_good_packet = Packet("", "ack", r.base - 1, r.base - 1)
            else:
                prev_good_packet = Packet("", "ack", r.packet_log.get_last_received(),
                                          r.packet_log.get_last_received())
            # if the socket timesout before any packets arrive r.address
            # would be empty
            if r.address != "":
                prev_good_packet.set_buffered(r.packet_log.get_prev_buffered())
                prev_good_packet.send_packet(r.sock, r.address)
            #sys.exit(-1)
